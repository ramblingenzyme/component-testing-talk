import base, { aspect, prism } from '@mdx-deck/themes';
import { Appear, FullScreenCode, Horizontal, Image, Notes, Split } from "mdx-deck";
import Title from "./components/Title";
import Counter from "./components/Counter";
import me from "./static/images/satvik.jpg";
import letMeIn from "./static/images/let-me-in.jpg";

export const theme = prism(base);

<Title />

---

<Split>

<img src={me} />

<div style={{ textAlign: "left", marginLeft: "20px" }}>

* Satvik Sharma
* Developer at Easy Agile
* Occasional flower crown wearer

</div>

</Split>

---

# What?
* Custom date picker field built using:
    * Atlaskit components
    * React + Hooks
* Supports setting min/max dates

<Notes>

* Pick a date from a calendar dropdown between optional date boundaries
* Atlaskit is Atlassian's UI library

</Notes>

---

# Why?
* Existing buggy implementation
* Can't use Atlaskit's
* Limited API surface

<Notes>

* Actually a rewrite of an existing component we've built
* Got fed up of the bugs, we'd fix one bug, introduce another
* 250 line Class component handling everything at once
* Atlaskit's date picker doesn't support min/max dates out of the box
* Calendar is such a powerful component and Datepicker hides it's powers

</Notes>

---

<Image src={letMeIn} size="contain" />

---

# How?

* Typescript
* Storybook
* React hooks
* @testing-library/jest-dom

<Appear>
    <div>
        <p>@testing-library/react</p>
        <p>The library formerly known as react-testing-library</p>
    </div>
</Appear>

<Notes>

* Typescript
    * made sure I was using the Atlaskit components correctly
    * sped up the dev loop because I didn't have to refer to the API docs all the time
* Storybook
    * for me there wasn't a huge barrier to linking to our app and trying out configurations
        * still great to have
    * let me write a different scenarios and keep them around
    * Let me turn experimenting with the component into tests easily
* React hooks
    * let me separate the concerns of the component
        * integrate them internally instead of layers of wrapping paper
    * open/close functionality
    * input validity
    * syncing input and calendar input
    * handling disabling dates and calendar state
* jest-dom
    * Jest matchers for the DOM.
    * Made assertions much more intuitive
    * Will be using in examples later on

</Notes>

---

# @testing-library
* Not specific to a test runner
* Wrappers for:
    * React
    * Angular
    * Vue
    * And more!

<Notes>

* Best used with Jest regardless
* Extra wrappers:
    * React Native
    * Svelte
    * Reason
    * Puppeteer
    * Cypress

</Notes>

---

# Approach

> The more your tests resemble the way your software is used, the more confidence they can give you.
> &mdash; *Kent C. Dodds*

<Notes>

* This quote is at the top of testing library's Guiding Principles page
* Test with DOM nodes
* Don't use component instances if possible
* Test how the user would use it

* Made sure I was testing the right things, what's rendered, not the implementation
* The connection between the implementation and the experience wasn't clear

</Notes>

---
<FullScreenCode>

```jsx
const HelloWorldSFC = (props) => <p> Hello world! </p>);

const HelloWorldFC = (props) => {
    const [displayValue] = useState("Hello world!");
    return <p>{displayValue}</p>;
}

class HelloWorld extends React.Component {
    render() {
        return <p>Hello world!</p>;
    }
}

describe("Hello world!", () => {
    it("should render", () => {
        const components = [
            HelloWorldSFC,
            HelloWorldFC,
            HelloWorld
        ];

        for (const Component of components) {
            const { getByText } = render(<Component />);
            expect(getByText("Hello world!")).toBeInTheDocument();
        }
    });
});

```

</FullScreenCode>

<Notes>

* Each of these components look the same to the user
* The test doesn't care about the implementation.
* Majority of my tests used getByText or similar and toBeInTheDocument.

</Notes>

---
// Put funny triumphant image here

---

# Counter

<Counter />
